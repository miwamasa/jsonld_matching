# JSON-LD Matching System 取り扱い説明書

## 目次

1. [システム概要](#システム概要)
2. [起動方法](#起動方法)
3. [基本操作](#基本操作)
4. [機能詳細](#機能詳細)
5. [実践例](#実践例)
6. [スコアの読み方](#スコアの読み方)
7. [トラブルシューティング](#トラブルシューティング)
8. [よくある質問](#よくある質問)

---

## システム概要

### このシステムは何をするのか？

JSON-LD Matching Systemは、JSON-LDドキュメントの `@context` に記述された**自然言語の説明文**を読み取り、外部の語彙カタログから最適な語彙定義を自動的に見つけ出すシステムです。

### 従来の問題点

通常のJSON-LDでは、語彙を使うために正確なURIを知っている必要があります：

```json
{
  "@context": "https://example.org/vocab/battery.jsonld",
  "capacity": 2000
}
```

しかし、この方法には以下の問題があります：
- 正確なURIを覚えておく必要がある
- URIが変更されると動作しなくなる
- 人間が読みにくい

### このシステムの解決策

自然言語の説明文を書くだけで、システムが自動的に適切な語彙を見つけます：

```json
{
  "@context": [{
    "description": "充電可能な単三電池で、容量はmAh、電圧、化学組成などの情報を持つ"
  }],
  "capacity": 2000,
  "capacityUnit": "mAh",
  "nominalVoltage": 1.2
}
```

システムが自動的に：
1. 説明文を分析
2. 語彙カタログから候補を検索
3. スコア付きでマッチング結果を提示
4. 正規化されたJSON-LDを生成
5. 派生プロパティ（エネルギー計算など）を追加

---

## 起動方法

### 必要なもの

- Webブラウザ（Chrome、Firefox、Safari、Edge など）
- Python 3（サーバー起動用）

### 起動手順

1. **ターミナル/コマンドプロンプトを開く**

2. **プロジェクトディレクトリに移動**
   ```bash
   cd /path/to/jsonld_matching
   ```

3. **サーバーを起動**
   ```bash
   python3 server.py
   ```

4. **以下のメッセージが表示されます**
   ```
   JSON-LD Matching System Server
   ================================
   Server running at: http://localhost:8000
   Open this URL in your browser to use the application
   Press Ctrl+C to stop the server
   ```

5. **ブラウザで開く**
   - ブラウザを開いて `http://localhost:8000` にアクセス

6. **停止方法**
   - ターミナルで `Ctrl+C` を押す

---

## 基本操作

### 画面構成

アプリケーションは3つのエリアで構成されています：

```
┌─────────────────────────────────────┐
│        ヘッダー（タイトル）         │
├──────────────┬──────────────────────┤
│              │                      │
│  入力エリア  │  マッチング結果      │
│  （左側）    │  （右側）            │
│              │                      │
├──────────────┴──────────────────────┤
│                                     │
│     正規化されたJSON-LD             │
│     （下部全幅）                    │
│                                     │
└─────────────────────────────────────┘
```

### 最初のステップ：サンプルを試す

1. **サンプルボタンをクリック**
   - 左上の「サンプル1 (AA NiMH)」ボタンをクリック
   - JSON-LDドキュメントが自動的に入力されます

2. **マッチング実行**
   - 「マッチング実行」ボタンをクリック
   - 数秒で結果が表示されます

3. **結果を確認**
   - 右側：候補語彙とスコア
   - 下部：正規化されたJSON-LD

### 独自のドキュメントを入力

1. **テキストエリアに入力**
   - 左側の大きなテキストエリアをクリック
   - JSONを入力（または貼り付け）

2. **必須項目**
   ```json
   {
     "@context": [{
       "description": "ここに説明文を書く"
     }],
     "@id": "urn:doc:example:001",
     "プロパティ名": "値"
   }
   ```

3. **注意点**
   - `@context` 内の `description` が必須
   - 有効なJSON形式で入力
   - 日本語も使用可能

---

## 機能詳細

### 1. マッチング閾値の調整

**閾値とは？**
- マッチング結果を「採用」するかどうかの基準値
- 0.00（すべて受け入れ）～ 1.00（完全一致のみ）

**調整方法**
1. スライダーをドラッグ
2. 数値が変化（例：0.75）
3. 再度「マッチング実行」で反映

**推奨値**
- **0.90以上**: 高信頼度のみ（保守的）
- **0.75-0.90**: バランス型（推奨）
- **0.50-0.75**: 多くの候補を見る（実験的）

### 2. マッチング結果の見方

各候補カードには以下の情報が表示されます：

```
┌──────────────────────────────────┐
│ capacity              [0.92]     │ ← ラベルとスコア
├──────────────────────────────────┤
│ ID: https://...#capacity         │
│ スコア内訳: E=0.86 R=0.95 L=0.92 │ ← 詳細スコア
│ 説明: Match based on lexical... │
├──────────────────────────────────┤
│ [lexical] [instance] [datatype]  │ ← 理由タグ
└──────────────────────────────────┘
```

**スコア内訳の意味**
- **E (Embedding)**: テキスト類似度（0～1）
- **R (Rule)**: ルールベース評価（0～1）
- **L (LLM)**: AI評価スコア（0～1）
- **最終スコア**: 0.45×E + 0.25×R + 0.30×L

**カードの色**
- 緑の左枠：閾値を超えて採用された
- 枠なし：候補だが不採用

### 3. 理由タイプの理解

マッチング結果には複数の「理由タグ」が表示されます：

| タイプ | 色 | 意味 | 例 |
|--------|-----|------|-----|
| lexical | 青 | 字句的一致 | 「capacity」という単語が一致 |
| semantic | 緑 | 意味的関連 | 「電池」と「バッテリー」の関連 |
| instance | 黄 | 値の一致 | 2000という値が例と一致 |
| datatype | 赤 | 型の互換性 | 整数型が期待通り |
| unitCompatibility | 紫 | 単位の互換性 | mAhとAhが変換可能 |

### 4. 正規化されたJSON-LD

マッチング後、標準化されたJSON-LDが生成されます：

**変換前**
```json
{
  "capacity": 2000,
  "capacityUnit": "mAh"
}
```

**変換後**
```json
{
  "batt:capacity": {
    "@value": 2000,
    "@type": "xsd:integer"
  },
  "batt:capacityUnit": "mAh"
}
```

**改善点**
- 語彙URIに変換（`batt:capacity`）
- 型情報を追加（`xsd:integer`）
- 標準名前空間を使用

### 5. 派生計算

システムは自動的に計算可能なプロパティを追加します。

**例：エネルギー計算**

入力データ：
- capacity: 2000 mAh
- nominalVoltage: 1.2 V

自動計算：
```
Wh = (mAh / 1000) × V
   = (2000 / 1000) × 1.2
   = 2.4 Wh
```

結果として `batt:energyWh` プロパティが追加され、計算ステップも記録されます。

---

## 実践例

### 例1：単三ニッケル水素電池

**ステップ1：ドキュメント作成**
```json
{
  "@context": [{
    "description": "充電可能な単三電池。容量は2000mAh、電圧1.2V、ニッケル水素"
  }],
  "@id": "urn:battery:aa-nimh-001",
  "@type": "BatteryDocument",
  "label": "エネループ 単三",
  "capacity": 2000,
  "capacityUnit": "mAh",
  "nominalVoltage": 1.2,
  "chemistry": "NiMH",
  "rechargeable": true
}
```

**ステップ2：マッチング実行**
- 「マッチング実行」ボタンをクリック

**期待される結果**
- capacity: スコア 0.85～0.95
- nominalVoltage: スコア 0.80～0.90
- chemistry: スコア 0.80～0.90
- rechargeable: スコア 0.75～0.85
- 派生プロパティ energyWh: 2.4 Wh

### 例2：18650リチウムイオン電池

**ステップ1：ドキュメント作成**
```json
{
  "@context": [{
    "description": "18650形状のリチウムイオン充電池。高容量で3500mAh、3.7V"
  }],
  "@id": "urn:battery:18650-li-001",
  "capacity": 3500,
  "capacityUnit": "mAh",
  "nominalVoltage": 3.7,
  "chemistry": "Li-ion",
  "size": "18650"
}
```

**ステップ2：マッチング実行**

**期待される結果**
- エネルギー: 12.95 Wh（自動計算）
- 高いマッチングスコア（0.85以上）

### 例3：曖昧な説明の処理

**ステップ1：短い説明で試す**
```json
{
  "@context": [{
    "description": "バッテリー"
  }],
  "@id": "urn:battery:vague-001",
  "someValue": 100
}
```

**期待される結果**
- 低いスコア（0.3～0.5）
- 多くの候補が不採用
- 説明文をより詳細にすることを推奨

**ステップ2：改善**
```json
{
  "@context": [{
    "description": "充電可能な電池で、容量と電圧の情報を持つ"
  }],
  ...
}
```

---

## スコアの読み方

### スコアの意味

| スコア範囲 | 信頼度 | 推奨アクション | 説明 |
|-----------|--------|---------------|------|
| 0.90～1.00 | 非常に高い | 自動採用 | ほぼ確実な一致 |
| 0.75～0.90 | 高い | 確認後採用 | 信頼できる一致 |
| 0.60～0.75 | 中程度 | 要レビュー | 可能性がある一致 |
| 0.40～0.60 | 低い | 注意が必要 | 弱い一致 |
| 0.00～0.40 | 非常に低い | 不採用推奨 | ほぼ無関係 |

### 良いマッチの特徴

**高スコアの候補は通常：**
- E（テキスト類似度）が 0.6 以上
- R（ルールスコア）が 0.8 以上
- 複数の理由タイプを持つ
- instance（実例）理由がある

**例：良いマッチ**
```
capacity: 0.92
├─ E: 0.85 (説明文に"capacity"という単語)
├─ R: 0.95 (値が整数、単位がmAh)
└─ L: 0.95 (複数の理由)
理由: lexical, instance, datatype, unitCompatibility
```

### 悪いマッチの特徴

**低スコアの候補は通常：**
- E（テキスト類似度）が 0.3 以下
- 理由タイプが1つだけ
- instance（実例）理由がない

**例：悪いマッチ**
```
warrantyPeriod: 0.25
├─ E: 0.05 (説明文に無関係)
├─ R: 0.10 (型は一致するが意味が違う)
└─ L: 0.60 (理由が弱い)
理由: datatype のみ
```

---

## トラブルシューティング

### 問題1：マッチング結果が0件

**症状**
- 「候補が見つかりませんでした」というエラー

**原因と解決策**

1. **@context に description がない**
   ```json
   // ❌ 間違い
   {
     "@context": {},
     "capacity": 2000
   }

   // ✅ 正しい
   {
     "@context": [{
       "description": "バッテリーの説明"
     }],
     "capacity": 2000
   }
   ```

2. **description が空**
   ```json
   // ❌ 間違い
   {
     "@context": [{
       "description": ""
     }]
   }

   // ✅ 正しい
   {
     "@context": [{
       "description": "少なくとも5文字以上の説明文"
     }]
   }
   ```

### 問題2：すべてのスコアが低い

**症状**
- 候補は見つかるが、すべて0.5以下のスコア

**原因と解決策**

1. **説明文が短すぎる**
   - 最低でも10～20文字の説明を書く
   - 具体的なキーワードを含める

2. **説明文が曖昧**
   ```
   ❌ 悪い例: "データ"
   ✅ 良い例: "バッテリーの容量をmAhで表したデータ"
   ```

3. **値が不足**
   - プロパティと値のペアを追加
   - 単位情報を含める

### 問題3：JSON解析エラー

**症状**
- 「エラーが発生しました: Unexpected token」

**原因と解決策**

1. **カンマの誤り**
   ```json
   // ❌ 間違い（最後のカンマ）
   {
     "capacity": 2000,
     "voltage": 1.2,
   }

   // ✅ 正しい
   {
     "capacity": 2000,
     "voltage": 1.2
   }
   ```

2. **引用符の誤り**
   ```json
   // ❌ 間違い（シングルクォート）
   {
     'capacity': 2000
   }

   // ✅ 正しい（ダブルクォート）
   {
     "capacity": 2000
   }
   ```

3. **コメントを含めた**
   - JSONはコメントをサポートしていません
   - すべてのコメントを削除

### 問題4：派生プロパティが生成されない

**症状**
- マッチングは成功するが energyWh が計算されない

**原因と解決策**

1. **必要なプロパティが不足**
   - エネルギー計算には capacity と nominalVoltage が必要
   ```json
   {
     "capacity": 2000,
     "capacityUnit": "mAh",
     "nominalVoltage": 1.2  // これが必要
   }
   ```

2. **値が文字列**
   ```json
   // ❌ 間違い
   {
     "capacity": "2000"  // 文字列
   }

   // ✅ 正しい
   {
     "capacity": 2000  // 数値
   }
   ```

### 問題5：アプリケーションが起動しない

**症状**
- ブラウザで「接続できません」エラー

**解決策**

1. **サーバーが起動しているか確認**
   - ターミナルで `python3 server.py` を実行
   - 「Server running at...」メッセージを確認

2. **ポート8000が使用中**
   ```bash
   # 別のポートを使用
   python3 -m http.server 8080
   # ブラウザで http://localhost:8080 にアクセス
   ```

3. **ファイアウォール設定**
   - localhostへのアクセスを許可

---

## よくある質問

### Q1: 日本語の説明文は使えますか？

**A:** はい、使えます。ただし、語彙カタログが英語の場合、英語の説明文の方がマッチング精度が高くなります。

### Q2: 独自の語彙カタログを作成できますか？

**A:** はい。`data/vocabulary_catalog.json` を編集することで、独自の語彙を追加できます。

フォーマット：
```json
{
  "id": "https://example.org/vocab/custom#myProperty",
  "label": "myProperty",
  "description": "プロパティの詳細な説明",
  "datatype": "integer|decimal|string|boolean",
  "units": ["単位1", "単位2"],
  "examples": [例1, 例2],
  "category": "カテゴリ名"
}
```

### Q3: マッチング精度を上げるには？

**A:** 以下の点に注意してください：
1. 説明文を具体的に（20文字以上）
2. 重要なキーワードを含める
3. 値と単位のペアを正確に
4. サンプル値を実際のデータに近づける

### Q4: 複数の語彙を同時にマッチングできますか？

**A:** はい。1つのドキュメントに複数のプロパティがある場合、それぞれが個別にマッチングされます。

### Q5: オフラインで使用できますか？

**A:** はい。すべての処理がローカルで実行されるため、インターネット接続は不要です。

### Q6: 大量のドキュメントを一括処理できますか？

**A:** 現在のWebアプリでは1件ずつですが、Node.jsのテストスクリプトを改造することで一括処理が可能です。

### Q7: 結果をエクスポートできますか？

**A:** 正規化されたJSON-LDをコピー&ペーストで保存できます。今後、ダウンロード機能を追加予定です。

### Q8: 実際のLLMを組み込めますか？

**A:** はい。`src/matching_engine.js` の `computeLLMScore` メソッドを、実際のLLM API（OpenAI GPT-4、Claude など）に置き換えることで可能です。

詳細は `spec/prompt_and_scoring.md` を参照してください。

### Q9: セキュリティは大丈夫ですか？

**A:** ローカル実行のため、データは外部に送信されません。ただし、実際のLLM APIを使用する場合は、データ送信に注意が必要です。

### Q10: このシステムの制限事項は？

**A:**
- テキスト類似度は簡易的（Jaccard類似度）
- LLMスコアはモック実装（ルールベース）
- 埋め込み検索は未実装
- 大規模データには不向き

本格的な運用には、README.md の「本格実装への拡張」を参照してください。

---

## まとめ

このJSON-LD Matching Systemは、自然言語の説明文から語彙を自動的にマッチングする革新的なツールです。

**主な利点**
- URIを覚える必要がない
- 人間が読みやすい
- スコアと理由で透明性が高い
- 派生計算で付加価値を提供

**始め方**
1. サーバーを起動
2. サンプルを試す
3. 独自のドキュメントを作成
4. 結果を確認・活用

**さらに学ぶには**
- [README.md](../README.md) - 技術的な詳細
- [仕様書](../spec/specification.md) - 設計思想
- [サンプルシナリオ](../spec/sample_scenario.md) - 具体例

質問や問題がある場合は、GitHubのIssuesで報告してください。

---

**バージョン**: 1.0
**最終更新**: 2025-10-27
**作成者**: Claude Code
